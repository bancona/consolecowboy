// Generated by CoffeeScript 1.9.3
(function() {
  var ParticleTree, Quadtree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Quadtree = (function() {
    function Quadtree(size1) {
      var level;
      this.size = size1;
      this.isRoot = bind(this.isRoot, this);
      this.isLeaf = bind(this.isLeaf, this);
      this.verifyIndex = bind(this.verifyIndex, this);
      this.convertIndexToCoordinates = bind(this.convertIndexToCoordinates, this);
      this.convertCoordinatesToIndex = bind(this.convertCoordinatesToIndex, this);
      this.getParentIndexByIndex = bind(this.getParentIndexByIndex, this);
      this.getValidChildIndicesByIndex = bind(this.getValidChildIndicesByIndex, this);
      this.getChildIndicesByIndex = bind(this.getChildIndicesByIndex, this);
      this.getPositionInLevel = bind(this.getPositionInLevel, this);
      this.getNodeAtIndex = bind(this.getNodeAtIndex, this);
      this.reset = bind(this.reset, this);
      if ((this.size = Math.floor(this.size / 1)) <= 0 || this.size & (this.size - 1)) {
        throw new Error('Quadtree size must be a positive power of 2.');
      }
      this.reset();
      this.lastLevel = this.getLevelByIndex(this.nodes.length - 1);
      this.startIndexOfLevel = (function() {
        var k, ref, results;
        results = [];
        for (level = k = 0, ref = this.lastLevel; 0 <= ref ? k <= ref : k >= ref; level = 0 <= ref ? ++k : --k) {
          results.push((Math.pow(2, 2 * level) - 1) / 3);
        }
        return results;
      }).call(this);
      this.maxNodes = (4 * Math.pow(this.size, 2) - 1) / 3;
    }

    Quadtree.prototype.reset = function() {
      this.nodes = {};
      return this;
    };

    Quadtree.prototype.getNodeAtIndex = function(index) {
      if (index in this.nodes) {
        return this.nodes[index];
      } else {
        return null;
      }
    };

    Quadtree.prototype.getLevelByIndex = function(index) {
      var log2;
      log2 = Math.log2 || function(x) {
        return Math.log(x) / Math.LN2;
      };
      return Math.floor(log2(3 * index + 1) / 2);
    };

    Quadtree.prototype.getPositionInLevel = function(index, level) {
      if (level == null) {
        level = this.getLevelByIndex(index);
      }
      return index - this.startIndexOfLevel[level];
    };

    Quadtree.prototype.getChildIndicesByIndex = function(index) {
      var childPositionInLevel, i, k, level, results, start;
      level = this.getLevelByIndex(index);
      if (level === this.lastLevel) {
        return [];
      }
      start = this.startIndexOfLevel[level + 1];
      childPositionInLevel = 4 * this.getPositionInLevel(index, level);
      results = [];
      for (i = k = 0; k < 4; i = ++k) {
        results.push(start + childPositionInLevel + i);
      }
      return results;
    };

    Quadtree.prototype.getValidChildIndicesByIndex = function(index) {
      var k, len, ref, results;
      ref = this.getChildIndicesByIndex;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        index = ref[k];
        if (index in this.nodes) {
          results.push(index);
        }
      }
      return results;
    };

    Quadtree.prototype.getParentIndexByIndex = function(index) {
      var level, parentLevel;
      level = this.getLevelByIndex(index);
      parentLevel = level - 1;
      return this.startIndexOfLevel[parentLevel] + Math.floor(this.getPositionInLevel(index, level) / 4);
    };

    Quadtree.prototype.convertCoordinatesToIndex = function(x, y) {
      var c, index, ref, ref1;
      if (!((0 <= (ref = (x = int(x))) && ref < this.size) && (0 <= (ref1 = (y = int(y))) && ref1 < this.size))) {
        throw new RangeError("Quadtree.convertCoordinatesToIndex(): Coordinates must be in range [0, " + this.size + ").");
      }
      c = 1;
      index = 0;
      while (!(x === 0 && y === 0)) {
        if (x & 1) {
          index |= c;
        }
        c <<= 1;
        x >>= 1;
        if (y & 1) {
          index |= c;
        }
        c <<= 1;
        y >>= 1;
      }
      return index + this.startIndexOfLevel[this.lastLevel];
    };

    Quadtree.prototype.convertIndexToCoordinates = function(index) {
      var c, x, y;
      this.verifyIndex(index);
      x = 0;
      y = 0;
      c = 1;
      index -= this.startIndexOfLevel[this.lastLevel];
      while (c <= index) {
        y |= c & index;
        index >>= 1;
        x |= c & index;
        c <<= 1;
      }
      return [x, y];
    };

    Quadtree.prototype.verifyIndex = function(index) {
      if (!(index === int(index) && (this.startIndexOfLevel[this.lastLevel] <= index && index < this.maxNodes))) {
        throw new RangeError("Quadtree.verifyIndex(): index must be in range [" + this.startIndexOfLevel[this.lastLevel] + ", @maxNodes).");
      }
    };

    Quadtree.prototype.isLeaf = function(index) {
      this.verifyIndex(index);
      return index >= this.startIndexOfLevel[this.lastLevel];
    };

    Quadtree.prototype.isRoot = function(index) {
      return index === 0;
    };

    return Quadtree;

  })();

  ParticleTree = (function(superClass) {
    extend(ParticleTree, superClass);

    function ParticleTree() {
      this.update = bind(this.update, this);
      this._moveParticles = bind(this._moveParticles, this);
      this._accelerateParticles = bind(this._accelerateParticles, this);
      this._sumForces = bind(this._sumForces, this);
      this._intercepts = bind(this._intercepts, this);
      this._maintainCentroids = bind(this._maintainCentroids, this);
      this._removeUnusedNodes = bind(this._removeUnusedNodes, this);
      this._getNewID = bind(this._getNewID, this);
      this.removeParticle = bind(this.removeParticle, this);
      this.addParticle = bind(this.addParticle, this);
      return ParticleTree.__super__.constructor.apply(this, arguments);
    }

    ParticleTree._X = 0;

    ParticleTree._Y = 1;

    ParticleTree._MASS = 2;

    ParticleTree._PARTICLES = 3;

    ParticleTree._VX = 3;

    ParticleTree._VY = 4;

    ParticleTree._G = 1;

    ParticleTree.MAX_PARTICLES = 1000;

    ParticleTree.prototype._particleID = 0;

    ParticleTree.prototype._particle_count = 0;

    ParticleTree.prototype.addParticle = function(x, y, mass, vx, vy) {
      var id, index, particle;
      if (mass == null) {
        mass = 1;
      }
      if (vx == null) {
        vx = 0;
      }
      if (vy == null) {
        vy = 0;
      }
      if (this._particle_count >= this.MAX_PARTICLES) {
        return false;
      }
      index = this.convertCoordinatesToIndex(x, y);
      id = this._getNewID();
      particle = [x, y, mass, vx, vy];
      if (index in this.nodes) {
        this.nodes[index][this._MASS] += mass;
        this.nodes[index][this._PARTICLES][id] = particle;
      } else {
        this.nodes[index] = [
          int(x), int(y), mass, {
            id: particle
          }
        ];
      }
      this._maintainCentroids(index);
      this._particle_count += 1;
      assert(int(this.nodes[index][this._PARTICLES][id][this._X]) === this.nodes[index][this._X] && int(this.nodes[index][this._PARTICLES][id][this._Y]) === this.nodes[index][this._Y]);
      return true;
    };

    ParticleTree.prototype.removeParticle = function(x, y, id) {
      var index, particle;
      index = this.convertCoordinatesToIndex(x, y);
      if (index in this.nodes && id in this.nodes[index][this._PARTICLES]) {
        this.nodes[index][this._MASS] -= this.nodes[index][this._PARTICLES][id][this._MASS];
        particle = this.nodes[index][this._PARTICLES][id];
        delete this.nodes[index][this._PARTICLES][id];
        this._maintainCentroids(index);
        this._removeUnusedNodes(index);
        this._particle_count -= 1;
        return particle;
      }
      return false;
    };

    ParticleTree.prototype._getNewID = function() {
      return (_particleID += 1).toString();
    };

    ParticleTree.prototype._removeUnusedNodes = function(index) {
      this.verifyIndex(index);
      while (!(this.nodes[index][this._MASS] > 0 || this.isRoot(index))) {
        delete this.nodes[index];
        index = this.getParentIndexByIndex(index);
      }
    };

    ParticleTree.prototype._maintainCentroids = function(index) {
      var base, base1, childIndex, k, l, len, name, name1, numChildren, property, ref, ref1;
      this.verifyIndex(index);
      while (!this.isRoot(index)) {
        index = this.getParentIndexByIndex(index);
        this.nodes[index] = [0, 0, 0];
        numChildren = 0;
        ref = this.getValidChildIndicesByIndex(index);
        for (k = 0, len = ref.length; k < len; k++) {
          childIndex = ref[k];
          numChildren += 1;
          for (property = l = 0, ref1 = this.nodes[index].length; 0 <= ref1 ? l < ref1 : l > ref1; property = 0 <= ref1 ? ++l : --l) {
            this.nodes[index][property] += this.nodes[childIndex][property];
          }
        }
        (base = this.nodes[index])[name = this._X] = Math.floor(base[name] / numChildren);
        (base1 = this.nodes[index])[name1 = this._Y] = Math.floor(base1[name1] / numChildren);
      }
    };

    ParticleTree.prototype._intercepts = function(x0, y0, index) {
      var indexOnLevel, level, nodeX, nodeY, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, size;
      level = this.getLevelByIndex(index);
      indexOnLevel = index - this.startIndexOfLevel[level];
      ref = this.convertIndexToCoordinates(indexOnLevel), nodeX = ref[0], nodeY = ref[1];
      size = this.size / Math.pow(2, level);
      nodeX *= size;
      nodeY *= size;
      if ((nodeX < x0 && x0 < nodeX + size) || (nodeY < y0 && y0 < nodeY + size)) {
        return true;
      }
      if ((nodeX < (ref1 = nodeY + x0 - y0) && ref1 < (nodeX + size)) || (nodeX < (ref2 = nodeY + size + x0 - y0) && ref2 < (nodeX + size)) || (nodeY < (ref3 = nodeX - x0 + y0) && ref3 < (nodeY + size)) || (nodeY < (ref4 = nodeX + size - x0 + y0) && ref4 < (nodeY + size))) {
        return true;
      }
      if ((nodeX < (ref5 = -nodeY + x0 - y0) && ref5 < (nodeX + size)) || (nodeX < (ref6 = -(nodeY + size) + x0 + y0) && ref6 < (nodeX + size)) || (nodeY < (ref7 = nodeX + x0 + y0) && ref7 < (nodeY + size)) || (nodeY < (ref8 = -(nodeX + size) + x0 + y0) && ref8 < (nodeY + size))) {
        return true;
      }
      return false;
    };

    ParticleTree.prototype._sumForces = function(x, y, id) {
      var getForce;
      getForce = function(index) {
        var childForces, force, forceX, forceY, gMassR2, i, k, len, node, r2;
        if (index == null) {
          index = 0;
        }
        if (this._intercepts(x, y, index)) {
          childForces = (function() {
            var k, len, ref, results;
            ref = this.getValidChildIndicesByIndex(index);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              i = ref[k];
              results.push(getForce(i));
            }
            return results;
          }).call(this);
          forceX = 0;
          forceY = 0;
          for (k = 0, len = childForces.length; k < len; k++) {
            force = childForces[k];
            forceX += force[0];
            forceY += force[1];
          }
        } else {
          node = this.nodes[index];
          r2 = Math.min(.01, Math.pow(x - node[this._X], 2) + Math.pow(y - node[this._Y], 2));
          gMassR2 = this._G * node[this._MASS] / r2;
          forceX = (node[this._X] - x) * gMassR2;
          forceY = (node[this._Y] - y) * gMassR2;
        }
        return [forceX, forceY];
      };
      return getForce();
    };

    ParticleTree.prototype._accelerateParticles = function(timeSteps, index) {
      var ax, ay, i, id, k, len, particle, ref, ref1, ref2, x, y;
      if (index == null) {
        index = 0;
      }
      if (this.isLeaf(index)) {
        x = this.nodes[index][this._X];
        y = this.nodes[index][this._Y];
        ref = this.nodes[index][this._PARTICLES];
        for (id in ref) {
          if (!hasProp.call(ref, id)) continue;
          particle = ref[id];
          ref1 = this._sumForces(x, y, id), ax = ref1[0], ay = ref1[1];
          particle[this._VX] += ax * timeSteps;
          particle[this._VY] += ay * timeSteps;
        }
      } else {
        ref2 = this.getValidChildIndicesByIndex(index);
        for (k = 0, len = ref2.length; k < len; k++) {
          i = ref2[k];
          _accelerateParticles(timeSteps, i);
        }
      }
    };

    ParticleTree.prototype._moveParticles = function(timeSteps, index) {
      var addVelocities, fixTree;
      if (index == null) {
        index = 0;
      }
      addVelocities = function(i) {
        var id, j, k, len, particle, ref, ref1, x, y;
        if (this.isLeaf(i)) {
          x = this.nodes[i][this._X];
          y = this.nodes[i][this._Y];
          ref = this.nodes[i][this._PARTICLES];
          for (id in ref) {
            if (!hasProp.call(ref, id)) continue;
            particle = ref[id];
            particle[this._X] += particle[this._VX] * timeSteps;
            particle[this._Y] += particle[this._VY] * timeSteps;
          }
        } else {
          ref1 = this.getValidChildIndicesByIndex(i);
          for (k = 0, len = ref1.length; k < len; k++) {
            j = ref1[k];
            addVelocities(j);
          }
        }
      };
      addVelocities(index);
      fixTree = function(i) {
        var id, j, k, len, particle, ref, ref1, x, y;
        if (this.isLeaf(i)) {
          x = this.nodes[i][this._X];
          y = this.nodes[i][this._Y];
          ref = this.nodes[i][this._PARTICLES];
          for (id in ref) {
            if (!hasProp.call(ref, id)) continue;
            particle = ref[id];
            if (int(particle[this._X]) !== x || int(particle[this._Y]) !== y) {
              this.removeParticle(x, y, id);
              this.addParticle.apply(this, particle);
            }
          }
        } else {
          ref1 = this.getValidChildIndicesByIndex(i);
          for (k = 0, len = ref1.length; k < len; k++) {
            j = ref1[k];
            fixTree(j);
          }
        }
      };
      fixTree(index);
    };

    ParticleTree.prototype.update = function(timeSteps) {
      this._accelerateParticles(timeSteps);
      this._moveParticles(timeSteps);
    };

    return ParticleTree;

  })(Quadtree);

}).call(this);
