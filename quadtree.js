// Generated by CoffeeScript 1.9.3
(function() {
  var ParticleTree, Quadtree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Quadtree = (function() {
    function Quadtree(size1) {
      var level;
      this.size = size1;
      this.isRoot = bind(this.isRoot, this);
      this.isLeaf = bind(this.isLeaf, this);
      this.verifyIndex = bind(this.verifyIndex, this);
      this.convertIndexToCoordinates = bind(this.convertIndexToCoordinates, this);
      this.convertCoordinatesToIndex = bind(this.convertCoordinatesToIndex, this);
      this.getParentIndexByIndex = bind(this.getParentIndexByIndex, this);
      this.getValidChildIndicesByIndex = bind(this.getValidChildIndicesByIndex, this);
      this.getChildIndicesByIndex = bind(this.getChildIndicesByIndex, this);
      this.getPositionInLevel = bind(this.getPositionInLevel, this);
      this.getNodeAtIndex = bind(this.getNodeAtIndex, this);
      this.reset = bind(this.reset, this);
      if ((this.size = Math.floor(this.size / 1)) <= 0 || this.size & (this.size - 1)) {
        throw new Error('Quadtree size must be a positive power of 2.');
      }
      this.reset();
      this.lastLevel = this.getLevelByIndex(this.nodes.length - 1);
      this.startIndexOfLevel = (function() {
        var j, ref, results;
        results = [];
        for (level = j = 0, ref = this.lastLevel; 0 <= ref ? j <= ref : j >= ref; level = 0 <= ref ? ++j : --j) {
          results.push((Math.pow(2, 2 * level) - 1) / 3);
        }
        return results;
      }).call(this);
      this.maxNodes = (4 * Math.pow(this.size, 2) - 1) / 3;
    }

    Quadtree.prototype.reset = function() {
      this.nodes = {};
      return this;
    };

    Quadtree.prototype.getNodeAtIndex = function(index) {
      if (index in this.nodes) {
        return this.nodes[index];
      } else {
        return null;
      }
    };

    Quadtree.prototype.getLevelByIndex = function(index) {
      var log2;
      log2 = Math.log2 || function(x) {
        return Math.log(x) / Math.LN2;
      };
      return Math.floor(log2(3 * index + 1) / 2);
    };

    Quadtree.prototype.getPositionInLevel = function(index, level) {
      if (level == null) {
        level = this.getLevelByIndex(index);
      }
      return index - this.startIndexOfLevel[level];
    };

    Quadtree.prototype.getChildIndicesByIndex = function(index) {
      var childPositionInLevel, i, j, level, results, start;
      level = this.getLevelByIndex(index);
      if (level === this.lastLevel) {
        return [];
      }
      start = this.startIndexOfLevel[level + 1];
      childPositionInLevel = 4 * this.getPositionInLevel(index, level);
      results = [];
      for (i = j = 0; j < 4; i = ++j) {
        results.push(start + childPositionInLevel + i);
      }
      return results;
    };

    Quadtree.prototype.getValidChildIndicesByIndex = function(index) {
      var j, len, ref, results;
      ref = this.getChildIndicesByIndex;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        index = ref[j];
        if (index in this.nodes) {
          results.push(index);
        }
      }
      return results;
    };

    Quadtree.prototype.getParentIndexByIndex = function(index) {
      var level, parentLevel;
      level = this.getLevelByIndex(index);
      parentLevel = level - 1;
      return this.startIndexOfLevel[parentLevel] + Math.floor(this.getPositionInLevel(index, level) / 4);
    };

    Quadtree.prototype.convertCoordinatesToIndex = function(x, y) {
      var c, index, ref, ref1;
      if (!((0 <= (ref = (x = int(x))) && ref < this.size) && (0 <= (ref1 = (y = int(y))) && ref1 < this.size))) {
        throw new RangeError("Quadtree.convertCoordinatesToIndex(): Coordinates must be in range [0, " + this.size + ").");
      }
      c = 1;
      index = 0;
      while (!(x === 0 && y === 0)) {
        if (x & 1) {
          index |= c;
        }
        c <<= 1;
        x >>= 1;
        if (y & 1) {
          index |= c;
        }
        c <<= 1;
        y >>= 1;
      }
      return index + this.startIndexOfLevel[this.lastLevel];
    };

    Quadtree.prototype.convertIndexToCoordinates = function(index) {
      var c, x, y;
      this.verifyIndex(index);
      x = 0;
      y = 0;
      c = 1;
      index -= this.startIndexOfLevel[this.lastLevel];
      while (c <= index) {
        y |= c & index;
        index >>= 1;
        x |= c & index;
        c <<= 1;
      }
      return [x, y];
    };

    Quadtree.prototype.verifyIndex = function(index) {
      if (!(index === int(index) && (this.startIndexOfLevel[this.lastLevel] <= index && index < this.maxNodes))) {
        throw new RangeError("Quadtree.verifyIndex(): index must be in range [" + this.startIndexOfLevel[this.lastLevel] + ", @maxNodes).");
      }
    };

    Quadtree.prototype.isLeaf = function(index) {
      this.verifyIndex(index);
      return index >= this.startIndexOfLevel[this.lastLevel];
    };

    Quadtree.prototype.isRoot = function(index) {
      return index === 0;
    };

    return Quadtree;

  })();

  ParticleTree = (function(superClass) {
    extend(ParticleTree, superClass);

    function ParticleTree() {
      this._sumForces = bind(this._sumForces, this);
      this._intercepts = bind(this._intercepts, this);
      this._maintainCentroids = bind(this._maintainCentroids, this);
      this._removeUnusedNodes = bind(this._removeUnusedNodes, this);
      this._getNewID = bind(this._getNewID, this);
      this.removeParticle = bind(this.removeParticle, this);
      this.addParticle = bind(this.addParticle, this);
      return ParticleTree.__super__.constructor.apply(this, arguments);
    }

    ParticleTree._X = 0;

    ParticleTree._Y = 1;

    ParticleTree._MASS = 2;

    ParticleTree._PARTICLES = 3;

    ParticleTree._VX = 3;

    ParticleTree._VY = 4;

    ParticleTree._G = 1;

    ParticleTree.MAX_PARTICLES = 1000;

    ParticleTree.prototype._particleID = 0;

    ParticleTree.prototype._particle_count = 0;

    ParticleTree.prototype.addParticle = function(x, y, vx, vy, mass) {
      var id, index, particle;
      if (vx == null) {
        vx = 0;
      }
      if (vy == null) {
        vy = 0;
      }
      if (mass == null) {
        mass = 1;
      }
      if (this._particle_count >= this.MAX_PARTICLES) {
        return false;
      }
      index = this.convertCoordinatesToIndex(x, y);
      id = this._getNewID();
      particle = [x, y, mass, vx, vy];
      if (index in this.nodes) {
        this.nodes[index][this._MASS] += mass;
        this.nodes[index][this._PARTICLES][id] = particle;
      } else {
        this.nodes[index] = [
          int(x), int(y), mass, {
            id: particle
          }
        ];
      }
      this._maintainCentroids(index);
      this._particle_count += 1;
      return true;
    };

    ParticleTree.prototype.removeParticle = function(x, y, id) {
      var index;
      index = this.convertCoordinatesToIndex(x, y);
      if (index in this.nodes && id in this.nodes[index][this._PARTICLES]) {
        this.nodes[index][this._MASS] -= this.nodes[index][this._PARTICLES][id][this._MASS];
        delete this.nodes[index][this._PARTICLES][id];
        this._maintainCentroids(index);
        this._removeUnusedNodes(index);
        this._particle_count -= 1;
        return true;
      }
      return false;
    };

    ParticleTree.prototype._getNewID = function() {
      return (_particleID += 1).toString();
    };

    ParticleTree.prototype._removeUnusedNodes = function(index) {
      this.verifyIndex(index);
      while (!(this.nodes[index][this._MASS] > 0 || this.isRoot(index))) {
        delete this.nodes[index];
        index = this.getParentIndexByIndex(index);
      }
    };

    ParticleTree.prototype._maintainCentroids = function(index) {
      var base, base1, childIndex, j, k, len, name, name1, numChildren, property, ref, ref1;
      this.verifyIndex(index);
      while (!this.isRoot(index)) {
        index = this.getParentIndexByIndex(index);
        this.nodes[index] = [0, 0, 0];
        numChildren = 0;
        ref = this.getValidChildIndicesByIndex(index);
        for (j = 0, len = ref.length; j < len; j++) {
          childIndex = ref[j];
          numChildren += 1;
          for (property = k = 0, ref1 = this.nodes[index].length; 0 <= ref1 ? k < ref1 : k > ref1; property = 0 <= ref1 ? ++k : --k) {
            this.nodes[index][property] += this.nodes[childIndex][property];
          }
        }
        (base = this.nodes[index])[name = this._X] = Math.floor(base[name] / numChildren);
        (base1 = this.nodes[index])[name1 = this._Y] = Math.floor(base1[name1] / numChildren);
      }
    };

    ParticleTree.prototype._intercepts = function(x, y, index) {
      var indexOnLevel, level, nodeX, nodeY, ref, ref1, ref2, ref3, ref4, size;
      level = this.getLevelByIndex(index);
      indexOnLevel = index - this.startIndexOfLevel[level];
      ref = this.convertIndexToCoordinates(indexOnLevel), nodeX = ref[0], nodeY = ref[1];
      size = this.size / Math.pow(2, level);
      nodeX *= size;
      nodeY *= size;
      if ((nodeX < x && x < nodeX + size) || (nodeY < y && y < nodeY + size)) {
        return true;
      }
      if ((nodeX < (ref1 = nodeY + x - y) && ref1 < nodeX + size) || (nodeX < (ref2 = nodeY + size + x - y) && ref2 < nodeX + size) || (nodeY < (ref3 = nodeX - x + y) && ref3 < nodeY + size) || (nodeY < (ref4 = nodeX + size - x + y) && ref4 < nodeY + size)) {
        return true;
      }
      return false;
    };

    ParticleTree.prototype._sumForces = function(x, y, id) {
      var getForce;
      getForce = function(index) {
        var childForces, force, forceX, forceY, gMassR2, i, j, len, node, r2;
        if (index == null) {
          index = 0;
        }
        if (this._intercepts(x, y, index)) {
          childForces = (function() {
            var j, len, ref, results;
            ref = this.getValidChildIndicesByIndex(index);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              results.push(getForce(i));
            }
            return results;
          }).call(this);
          forceX = 0;
          forceY = 0;
          for (j = 0, len = childForces.length; j < len; j++) {
            force = childForces[j];
            forceX += force[0];
            forceY += force[1];
          }
        } else {
          node = this.nodes[index];
          r2 = Math.pow(x - node[this._X], 2) + Math.pow(y - node[this._Y], 2);
          gMassR2 = this._G * node[this._MASS] / r2;
          forceX = (node[this._X] - x) * gMassR2;
          forceY = (node[this._Y] - y) * gMassR2;
        }
        return [forceX, forceY];
      };
      return getForce();
    };

    return ParticleTree;

  })(Quadtree);

}).call(this);
